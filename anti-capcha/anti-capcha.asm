section 'anti-cap' data readable writable code executable

INTERNET_DEFAULT_HTTP_PORT = 80
INTERNET_SERVICE_HTTP = 3
INTERNET_FLAG_RELOAD = 80000000h

struct cap
    hash dd ?
    str  rb 5
ends

buff_size = 1024*1024

arraycapcha FILE 'save'
arrcpchacnt = ($-arraycapcha)/sizeof.cap
curstr rb 7

url1	db 'http://www.md5decrypter.co.uk'
req1	db '/ntlm-decrypt.aspx',0
url2	db 'http://www.md5decrypter.co.uk/controls/captcha.aspx',0
header	db 'Content-Type: application/x-www-form-urlencoded',13,10,'User-agent: Opera/9.80 (Windows NT 6.1; U; es-ES) Presto/2.9.181 Version/12.00',0
sizeheader = $-header-1
post	db 'ctl00%%24ScriptManager1=ctl00%%24MainContent%%24updDecrypt%%7Cctl00%%24MainContent%%24btnDecrypt',\
	   '&ctl00%%24MainContent%%24txtHashes=%s',\
	   '&ctl00%%24MainContent%%24txtCaptcha=%s',\
	   '&__EVENTTARGET=ctl00%%24MainContent%%24btnDecrypt',\
	   '&__EVENTARGUMENT=',\
	   '&__EVENTVALIDATION=%s',\
	   '&__VIEWSTATE=%s',\
	   '&__ASYNCPOST=true',0
hSession dd ?
capcha_buff dd ?

proc acapcha
	local res:DWORD

	mov [res],0
	invoke GlobalAlloc,GPTR,buff_size
	test eax,eax
	je .exit
	mov [capcha_buff],eax
	INTERNET_OPEN_TYPE_PRECONFIG = 0
	invoke InternetOpenA,0,INTERNET_OPEN_TYPE_PRECONFIG,0,0,0
	test eax,eax
	je .exit
	mov [hSession],eax
     .start:
	stdcall loadimage,url1,0
	.if eax<>0
		mov eax,[capcha_buff]
		lea ebx,[eax+buff_size]
		@@:
		inc eax
		cmp eax,ebx
		je .exit1
		cmp dword [eax],'E" v'
		jne @b
		add eax,10
		mov esi,eax
		@@:
		inc esi
		cmp esi,ebx
		je .exit1
		cmp dword [esi],'" />'
		jne @b
		mov dword [esi],0
		push esi
		push ebx
		stdcall urlencode,eax,viewstate,512
		pop ebx
		pop esi
		@@:
		inc esi
		cmp esi,ebx
		je .exit1
		cmp dword [esi],'N" v'
		jne @b
		add esi,10
		mov eax,esi
		@@:
		inc eax
		cmp eax,ebx
		je .exit1
		cmp dword [eax],'" />'
		jne @b
		mov dword [eax],0
		stdcall urlencode,esi,eventval,128
		stdcall loadimage,url2,1
		test eax,eax
		je .exit1
		cinvoke wsprintfA,[capcha_buff],post,result,curstr,eventval,viewstate
		stdcall loadimage,req1,2
		test eax,eax
		je .exit1
		stdcall regexec,regex3,[capcha_buff];(REGEX_T *regex_t, char *string)
		.if eax<>REGEX_NOMATCH
			mov eax,[capcha_buff]
			lea ebx,[eax+buff_size]
			@@:
			inc eax
			cmp eax,ebx
			je .exit1
			cmp dword [eax],'66">'
			jne @b
			add eax,4
			mov ecx,eax
			@@:
			inc ecx
			cmp ecx,ebx
			je .exit1
			cmp dword [ecx],'</fo'
			jne @b
			mov dword [ecx],0
			invoke lstrcpyA,passwd,eax
			mov [res],1
		.else
			stdcall regexec,regex4,[capcha_buff];(REGEX_T *regex_t, char *string)
			cmp eax,REGEX_NOMATCH
			jne .start
		.endif
	.endif
      .exit1:
	invoke GlobalFree,[capcha_buff]
	invoke InternetCloseHandle,[hSession]
	mov eax,[res]
      .exit:
	ret
endp

proc loadimage url,md
	local BufferLen:DWORD
	local cnt:DWORD
	local hConnect:DWORD
	local hRequest:DWORD

	.if [md]=2
		invoke InternetConnectA,[hSession],host3,INTERNET_DEFAULT_HTTP_PORT,0,0,INTERNET_SERVICE_HTTP,0,0
		.if eax<>0
			mov [hConnect],eax
			invoke HttpOpenRequestA,eax,"POST",[url],0,0,0,INTERNET_FLAG_RELOAD,0
			.if eax<>0
				mov [hRequest],eax
				invoke lstrlenA,[capcha_buff]
				invoke HttpSendRequestA,[hRequest],header,sizeheader,[capcha_buff],eax
				.if eax<>0
					jmp .req
				.endif
				invoke InternetCloseHandle,[hRequest]
			.endif
			invoke InternetCloseHandle,[hConnect]
		.endif
		xor eax,eax
		jmp .exit
	.endif
	mov [cnt],0
      .start:
	invoke InternetOpenUrlA,[hSession],[url],0,0,0,0
	test eax,eax
	je .err1
	mov [hRequest],eax
       .req:
	lea eax,[BufferLen]
	invoke InternetReadFile,[hRequest],[capcha_buff],buff_size,eax
	invoke InternetCloseHandle,[hRequest]
	.if [md]=0
		mov eax,1
		jmp .exit
	.elseif [md]=2
		invoke InternetCloseHandle,[hConnect]
		xor eax,eax
		inc eax
		jmp .exit
	.endif
	stdcall getcrc32,[capcha_buff],[BufferLen]
	stdcall fndinarray,eax
	.if eax<>0
		lea eax,[eax+cap.str]
		push 6
		push curstr
		push eax
		invoke RtlZeroMemory,curstr,7
		stdcall decabc
	.else
		inc [cnt]
		.if [cnt]=3
			jmp .err1
		.endif
		jmp .start
	.endif
	xor eax,eax
	inc eax
      .exit:
	ret
      .err1:
	xor eax,eax
	jmp .exit
endp

proc crcinit CrtTable
	xor ebx, ebx
	mov edx,[CrtTable]
      .InitTableLoop:
	xor eax, eax
	mov al, bl
	xor ecx,ecx
      .entryLoop:
	test eax, 1
	jz .no_topbit
	shr eax, 1
	xor eax, 0edb88320h
	jmp .entrygoon
      .no_topbit:
	shr eax, 1
      .entrygoon:
	inc ecx
	test ecx, 8
	jz .entryLoop
	mov dword [ebx*4 + edx], eax
	inc ebx
	test ebx, 256
	jz .InitTableLoop
	ret
endp

proc getcrc32 data,size
	mov eax,-1
	mov esi,[data]
	mov ecx,[size]

      .computeLoop:
	xor ebx, ebx
	xor al, [esi]
	mov bl, al
	shr eax, 8
	xor eax, dword [4*ebx + CrtTable]
	inc esi
	loop .computeLoop
	xor eax,0FFFFFFFFh
	ret
endp

proc fndinarray hash
	mov ecx,arrcpchacnt
	mov eax,arraycapcha
	mov edi,[hash]
	@@:
	cmp edi,dword [eax]
	je @f
	add eax,sizeof.cap
	loop @b
       .er1:
	xor eax,eax
	@@:
	ret
endp

proc decabc str,str2,cnt
	xor eax,eax
	xor ecx,ecx
	mov esi,[str]
	mov edi,[str2]
	@@:
	.if ecx=4
		add esi,3
		xor ecx,ecx
	.endif
	inc ecx
	.if ecx=1
		mov bl,byte [esi]
		and bl,03Fh ; 111111
	.elseif ecx=2
		mov bx,word [esi]
		shr bx,6
		and bl,03Fh ; 111111
	.elseif ecx=3
		mov ebx,dword [esi]
		shr ebx,12
		and bl,03Fh ; 111111
	.elseif ecx=4
		mov ebx,dword [esi]
		shr ebx,18
		and bl,03Fh ; 111111
	.endif
	.if eax=[cnt]
		jmp .exit
	.elseif bl>=1 & bl<=26
		add bl,'a'-1
	.elseif bl>=27 & bl<=52
		add bl,'A'-26-1
	.elseif bl>=53 & bl<=62
		add bl,'0'-52-1
	.elseif bl=0
		jmp .exit
	.endif
	mov byte [edi],bl
	inc edi
	inc eax
	jmp @b
      .exit:
	ret
endp

CrtTable rd 256
eventval rb 128
viewstate rb 512