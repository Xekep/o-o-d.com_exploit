format pe gui 4.0
include '%fasm_inc%\win32ax.inc'

ID_OK  = 1
ID_STR	= 2
ID_IMAGE = 3
ID_NEXT  = 4
ID_CHECK = 5
ID_SAVE = 6
ID_STAT = 7
ID_STATIC = 8

buff_size = 2048

struct GdiplusStartupInput
    GdiplusVersion dd ?
    DebugEventCallback dd ?
    SuppressBackgroundThread dd ?
    SuppressExternalCodecs dd ?
ends

struct cap
    hash dd ?
    str  rb 5
ends

.data
data resource
  directory RT_DIALOG,dialogs

  resource dialogs,\
	   1,LANG_ENGLISH+SUBLANG_DEFAULT,main1

  dialog main1,'Capcha 1.0',70,70,190,105,WS_CAPTION+WS_POPUP+WS_SYSMENU+DS_MODALFRAME+DS_CENTER
    dialogitem 'STATIC',0,ID_IMAGE,55,15,0,0,WS_VISIBLE+SS_BITMAP
    dialogitem 'STATIC',0,ID_STATIC,168,10,20,10,WS_VISIBLE
    dialogitem 'STATIC','&Str:',-1,10,50,70,8,WS_VISIBLE
    dialogitem 'EDIT','',ID_STR,10,60,170,13,WS_VISIBLE+WS_BORDER+WS_TABSTOP+BS_FLAT
    dialogitem 'BUTTON','OK',ID_OK,85,85,45,15,WS_VISIBLE+WS_TABSTOP+BS_PUSHBUTTON+BS_FLAT
    dialogitem 'BUTTON','N&ext',ID_NEXT,135,85,45,15,WS_VISIBLE+WS_TABSTOP+BS_PUSHBUTTON+BS_FLAT
    dialogitem 'BUTTON','Check',ID_CHECK,10,85,65,15,WS_VISIBLE+WS_TABSTOP+BS_PUSHBUTTON+BS_FLAT
    dialogitem 'BUTTON','Save',ID_SAVE,10,10,25,15,WS_VISIBLE+WS_TABSTOP+BS_PUSHBUTTON+BS_FLAT
    dialogitem 'BUTTON','Stat',ID_STAT,10,27,25,15,WS_VISIBLE+WS_TABSTOP+BS_PUSHBUTTON+BS_FLAT
  enddialog
end data
gdiplusSInput GdiplusStartupInput 1,0,0,0
gdiplusToken dd ?
filename db 'save',0
url db 'http://www.md5decrypter.co.uk/controls/captcha.aspx',0
oldwprocedit dd ?
CrtTable rd 256
capcha_buff dd ?
capcha_buff2 dd ?
hImg dd ?
hbmp dd 0
curstr rb 7
count dd 0
chck db 0
hashdata cap

.code
start:
     ;   invoke RtlZeroMemory,CrtTable,15
     ;   stdcall encabc,strr,CrtTable,6
     ;   invoke RtlZeroMemory,filename,15
     ;   stdcall decabc,CrtTable,filename,6
     ;   invoke MessageBoxA,0,filename,0,0
     ;   jmp exit
     ;   strr db '12sF91',0
	; 6b log2(64)=6
	; 6*6=36/8=4,5
	stdcall crcinit,CrtTable
	invoke GdiplusStartup,gdiplusToken,gdiplusSInput,0
	invoke GlobalAlloc,GPTR,buff_size
	test eax,eax
	je exit
	mov [capcha_buff],eax
	invoke GlobalAlloc,GPTR,sizeof.cap*1000
	mov [capcha_buff2],eax
	invoke _lopen,filename,0
	cmp eax,-1
	je @f
	push eax
	invoke _lread,eax,[capcha_buff2],sizeof.cap*1000
	invoke _lclose
	@@:
	invoke GetModuleHandleA,0
	invoke DialogBoxParamA,eax,1,HWND_DESKTOP,dialog1,0
	invoke GlobalFree,[capcha_buff]
	invoke GlobalFree,[capcha_buff2]
	.if [hbmp]<>0
		invoke DeleteObject,[hbmp]
	.endif
	exit:
	invoke ExitProcess,0

proc addarray
	mov eax,[count]
	lea eax,[eax*sizeof.cap]
	add eax,[capcha_buff2]
	invoke RtlMoveMemory,eax,hashdata,sizeof.cap
	ret
endp

proc arrcount
	xor eax,eax
	mov ecx,1000
	mov esi,[capcha_buff2]
	@@:
	.if dword [esi]=0
		jmp .exit
	.endif
	add esi,sizeof.cap
	inc eax
	loop @b
       .exit:
	mov [count],eax
	ret
endp

proc fndinarray hash
	mov ecx,[count]
	cmp ecx,0
	je .er1
	mov eax,[capcha_buff2]
	mov edi,[hash]
	@@:
	cmp edi,dword [eax]
	je @f
	add eax,sizeof.cap
	loop @b
       .er1:
	xor eax,eax
	@@:
	ret
endp

proc decabc str,str2,cnt
	xor eax,eax
	xor ecx,ecx
	mov esi,[str]
	mov edi,[str2]
	@@:
	.if ecx=4
		add esi,3
		xor ecx,ecx
	.endif
	inc ecx
	.if ecx=1
		mov bl,byte [esi]
		and bl,03Fh ; 111111
	.elseif ecx=2
		mov bx,word [esi]
		shr bx,6
		and bl,03Fh ; 111111
	.elseif ecx=3
		mov ebx,dword [esi]
		shr ebx,12
		and bl,03Fh ; 111111
	.elseif ecx=4
		mov ebx,dword [esi]
		shr ebx,18
		and bl,03Fh ; 111111
	.endif
	.if eax=[cnt]
		jmp .exit
	.elseif bl>=1 & bl<=26
		add bl,'a'-1
	.elseif bl>=27 & bl<=52
		add bl,'A'-26-1
	.elseif bl>=53 & bl<=62
		add bl,'0'-52-1
	.elseif bl=0
		jmp .exit
	.endif
	mov byte [edi],bl
	inc edi
	inc eax
	jmp @b
      .exit:
	ret
      ;  .abc1 db 'abcdefghijklmnopqrstuvwxyz',0 ;1-26
      ;  .abc2 db 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',0 ;27-52
      ;  .abc3 db '0123456789',0                 ;53-62
endp

proc encabc str,str2,cnt
	mov esi,[str]
	mov edi,[str2]
	xor eax,eax
	xor ecx,ecx
	xor ebx,ebx
	@@:
	.if ecx=4
		xor ecx,ecx
		add edi,3
	.endif
	inc ecx
	.if eax=[cnt]
		jmp .exit
	.elseif byte [esi]>='a' & byte [esi]<='z'
		mov bl,byte [esi]
		sub bl,'a'-1
		inc esi
		inc eax
		stdcall .sav
		jmp @b
	.elseif byte [esi]>='A' & byte [esi]<='Z'
		mov bl,byte [esi]
		sub bl,'A'-26-1
		inc esi
		inc eax
		stdcall .sav
		jmp @b
	.elseif byte [esi]>='0' & byte [esi]<='9'
		mov bl,byte [esi]
		sub bl,'0'-52-1
		inc esi
		inc eax
		stdcall .sav
		jmp @b
	.elseif byte [esi]<>0
		xor eax,eax
	.endif
      .exit:
	ret
      .sav:
	.if ecx=1
		or [edi],ebx
	.elseif ecx=2
		shl ebx,6
		or [edi],ebx
	.elseif ecx=3
		shl ebx,12
		or [edi],ebx
	.elseif ecx=4
		shl ebx,18
		or [edi],ebx
	.endif
	xor ebx,ebx
	retn

       ; .abc1 db 'abcdefghijklmnopqrstuvwxyz',0 ;1-26
       ; .abc2 db 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',0 ;27-52
       ; .abc3 db '0123456789',0                 ;53-62
endp

proc dialog1 hwnd,msg,wparam,lparam
	push  ebx edi esi
	cmp [msg],WM_CLOSE
	je .wmclose
	cmp [msg],WM_LBUTTONDOWN
	je .move
	.if [msg]=WM_INITDIALOG
		stdcall arrcount
		invoke GetDlgItem,[hwnd],ID_STR
		invoke SetWindowLong,eax,GWL_WNDPROC,WProcEdit
		mov [oldwprocedit],eax
		invoke GetDlgItem,[hwnd],ID_IMAGE
		mov [hImg],eax
		jmp .processed
	.elseif [msg]=WM_COMMAND
		.if [wparam]=BN_CLICKED shl 16 + ID_OK
			.if [hbmp]<>0
				invoke DeleteObject,[hbmp]
				mov [hbmp],0
				invoke GetDlgItemTextA,[hwnd],ID_STR,curstr,7
				test eax,eax
				je @f
				cmp [hashdata.hash],0
				je @f
				invoke RtlZeroMemory,hashdata.str,5
				stdcall encabc,curstr,hashdata.str,6
				stdcall addarray
				inc [count]
				invoke SetDlgItemTextA,[hwnd],ID_STR,0
				@@:
			.endif
			invoke CreateThread,0,0,loadimage,[hwnd],0,0
			jmp .processed
		.elseif [wparam]=BN_CLICKED shl 16 + ID_NEXT
			.if [hbmp]<>0
				invoke DeleteObject,[hbmp]
				mov [hbmp],0
			.endif
			invoke CreateThread,0,0,loadimage,[hwnd],0,0
			jmp .processed
		.elseif [wparam]=BN_CLICKED shl 16 + ID_CHECK
			.if [hbmp]<>0
				invoke DeleteObject,[hbmp]
				mov [hbmp],0
			.endif
			mov [chck],1
			invoke SetDlgItemTextA,[hwnd],ID_STR,0
			invoke CreateThread,0,0,loadimage,[hwnd],0,0
			jmp .processed
		.elseif [wparam]=BN_CLICKED shl 16 + ID_SAVE
			invoke _lcreat,filename,0
			.if eax=-1
				invoke MessageBoxA,[hwnd],'ERR',0,MB_ICONINFORMATION+MB_OK
				jmp .processed
			.endif
			push eax
			mov ecx,[count]
			lea ecx,[ecx*sizeof.cap]
			invoke _lwrite,eax,[capcha_buff2],ecx
			invoke _lclose
			jmp .processed
		.elseif [wparam]=BN_CLICKED shl 16 + ID_STAT
			cinvoke wsprintfA,curstr,'%u',[count]
			invoke MessageBoxA,[hwnd],curstr,0,MB_ICONINFORMATION+MB_OK
			jmp .processed
		.endif
	.endif
	xor eax,eax
	jmp .finish
     .move:
	invoke ReleaseCapture
	invoke SendMessageA,[hwnd],WM_NCLBUTTONDOWN,2,0
	jmp .processed
     .wmclose:
	invoke EndDialog,[hwnd],0
     .processed:
	mov eax,1
     .finish:
	pop esi edi ebx
	ret
endp
proc loadimage hwnd
	local hUrl:DWORD
	local hSession:DWORD
	local BufferLen:DWORD
	local cnt:DWORD

	invoke GetDlgItem,[hwnd],ID_OK
	invoke EnableWindow,eax,0
	invoke GetDlgItem,[hwnd],ID_NEXT
	invoke EnableWindow,eax,0
	invoke GetDlgItem,[hwnd],ID_CHECK
	invoke EnableWindow,eax,0
	mov [cnt],0
      .start:
	INTERNET_OPEN_TYPE_PRECONFIG = 0
	invoke InternetOpenA,0,INTERNET_OPEN_TYPE_PRECONFIG,0,0,0
	test eax,eax
	je .err1
	mov [hSession],eax
	invoke InternetOpenUrlA,[hSession],url,0,0,0,0
	test eax,eax
	je .err2
	mov [hUrl],eax
	lea eax,[BufferLen]
	invoke InternetReadFile,[hUrl],[capcha_buff],buff_size,eax
	invoke InternetCloseHandle,[hUrl]
       .err2:
	invoke InternetCloseHandle,[hSession]
	stdcall getcrc32,[capcha_buff],[BufferLen]
	mov [hashdata.hash],eax
	stdcall fndinarray,eax
	.if eax<>0 & [chck]=1
		mov [chck],0
		mov [hashdata.hash],0
		lea eax,[eax+cap.str]
		push 6
		push curstr
		push eax
		invoke RtlZeroMemory,curstr,7
		stdcall decabc
		invoke SetDlgItemTextA,[hwnd],ID_STR,curstr
	.elseif eax<>0
		inc [cnt]
		cinvoke wsprintfA,curstr,'%u',[cnt]
		invoke SetDlgItemTextA,[hwnd],ID_STATIC,curstr
		.if [cnt]=250
			invoke SendMessageA,[hImg],STM_SETIMAGE,IMAGE_BITMAP,0
			invoke MessageBoxA,[hwnd],'250 капч распознано!',0,MB_ICONINFORMATION+MB_OK
			invoke SetDlgItemTextA,[hwnd],ID_STATIC,0
			jmp .exit
		.endif
		jmp .start
	.endif
	stdcall GdiLoad,[capcha_buff],[BufferLen],hbmp,0
	.if eax<>0
		invoke SendMessageA,[hImg],STM_SETIMAGE,IMAGE_BITMAP,[hbmp]
	.else
		jmp .err1
	.endif
      .exit:
	invoke GetDlgItem,[hwnd],ID_OK
	invoke EnableWindow,eax,1
	invoke GetDlgItem,[hwnd],ID_NEXT
	invoke EnableWindow,eax,1
	invoke GetDlgItem,[hwnd],ID_CHECK
	invoke EnableWindow,eax,1
	invoke ExitThread,0
      .err1:
	invoke MessageBoxA,[hwnd],'ERR',0,MB_ICONWARNING+MB_OK
	jmp .exit
endp

proc crcinit CrtTable
	xor ebx, ebx
	mov edx,[CrtTable]
      .InitTableLoop:
	xor eax, eax
	mov al, bl
	xor ecx,ecx
      .entryLoop:
	test eax, 1
	jz .no_topbit
	shr eax, 1
	xor eax, 0edb88320h
	jmp .entrygoon
      .no_topbit:
	shr eax, 1
      .entrygoon:
	inc ecx
	test ecx, 8
	jz .entryLoop
	mov dword [ebx*4 + edx], eax
	inc ebx
	test ebx, 256
	jz .InitTableLoop
	ret
endp

proc getcrc32 data,size
	mov eax,-1
	mov esi,[data]
	mov ecx,[size]

      .computeLoop:
	xor ebx, ebx
	xor al, [esi]
	mov bl, al
	shr eax, 8
	xor eax, dword [4*ebx + CrtTable]
	inc esi
	loop .computeLoop
	xor eax,0FFFFFFFFh
	ret
endp

proc GdiLoad mem,size,hbitmap,alpha
	local pIStream:DWORD
	local hIStream:DWORD
	local mem2:DWORD
	local pmem2:DWORD
	local image:DWORD

	invoke GlobalAlloc,GMEM_MOVEABLE,[size]
	test eax,eax
	je .exit0
	mov [mem2],eax
	invoke GlobalLock,eax
	mov [pmem2],eax
	invoke RtlMoveMemory,eax,[mem],[size]
	lea eax,[pIStream]
	invoke CreateStreamOnHGlobal,[pmem2],0,eax
	test eax,eax
	jne .exit1
	mov [image],0
	lea eax,[image]
	invoke GdipCreateBitmapFromStream,[pIStream],eax
	lea ecx,[hIStream]
	invoke GetHGlobalFromStream,[pIStream],ecx
	lea eax,[image]
	invoke GdipDisposeImage,eax
	mov eax,[hbitmap]
	invoke GdipCreateHBITMAPFromBitmap,[image],eax,[alpha]
	invoke GlobalUnlock,[pmem2]
	invoke GlobalFree,[mem2]
	mov eax,[image]
	ret
     .exit1:
	invoke GlobalUnlock,[pmem2]
	invoke GlobalFree,[mem2]
     .exit0:
	xor eax,eax
	ret
endp

proc WProcEdit hwnd,msg,wparam,lparam
	.if [msg]=WM_CHAR
		.if [wparam]>='0' & [wparam]<='9'
			jmp @f
		.elseif [wparam]>='a' & [wparam]<='z'
			jmp @f
		.elseif [wparam]>='A' & [wparam]<='Z'
			jmp @f
		.elseif [wparam]=VK_BACK
			jmp @f
		.endif
		jmp .finish
	.endif
	@@:
	invoke CallWindowProc,[oldwprocedit],[hwnd],[msg],[wparam],[lparam]
	ret
     .finish:
	xor eax,eax
	ret
endp
.end start
